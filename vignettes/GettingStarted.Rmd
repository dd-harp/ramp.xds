---
title: "Getting Started"
subtitle: "A ramp.xds Demo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# 

**`ramp.xds`** was developed to reduce the costs of building, solving, analyzing, and using models describing the epidemiology, transmission dynamics and control of malaria and other mosquito-transmitted pathogens. This vignette gives a demonstration and a basic introduction. 

Another useful vignette is [Working with Models](Working.html). 

## Installation 

The software was developed in RStudio. To download the R package, run these commands: 

```{r, eval=F}
library(devtools)
devtools::install_github("dd-harp/ramp.xds")
```

Then load **`ramp.xds`**: 

```{r}
library(ramp.xds)
```

```{r, echo=F}
#devtools::load_all()
```

Additional modules are available in the companion R-package [**`ramp.library`**](https://dd-harp.github.io/ramp.library/)

## Demo

With **`ramp.xds`** it's easy to build models for the transmission dynamics and control of malaria or other mosquito-borne pathogens. 
Model building in **`ramp.xds`** starts 
with a function called `xds_setup().`
All arguments in `xds_setup()` are assigned default values, so calling `xds_setup()` with no arguments returns a fully configured model with all the default settings. 

```{r}
model <- xds_setup()
```

The object `model` returned by `xds_setup()` is called a **`ramp`** *model object:* it is a fully defined model that can be solved by `xds_solve()`. 



Later, after solving the equations, it won't be empty. 

### Defaults 

The arguments are stored and can be easily retrieved. The name of the module for human / host infection and immune dynamics is stored as `Xname.` The default module is the `SIS` compartmental model:

```{r}
model$Xname
```

`SIS` was set up with default parameter values, that can be viewed with the function `get_Xpars`: 

```{r}
get_Xpars(model)
```
Functions like `get_Xpars` are designed to help users get to know the model oject. In this case, the parameters are stored as `model$Xpar[[i]],` for the $i^{th}$ species. Knowing the names, the parameters can then be viewed (or changed):

```{r}
model$Xpar[[1]]$r
```

The defaults can be over-written at setup by passing `Xopts = list(...)` with different values: 

```{r}
Xo = list(b=1/150, c=0.2, b=0.6)
model1 <- xds_setup(Xopts = Xo)
get_Xpars(model1)
```
Similarly, initial values were assigned default values at setup:

```{r}
get_Xinits(model)
```

The name of the default module for adult mosquito ecology and infection dynamics is called `MYZname.` The default module is Macdonald's model: 

```{r}
model$MYZname
```

The design pattern is followed: once again, parameters can be viewed with `get_MYZpars` and the method for setting parameter values by passing a named list of values to `MYZopts` in `xds_setup()` 

The name of the default module for aquatic mosquito ecology is called `Lname.` The default module is the `trivial` module: 

```{r}
model$Lname
```

For the `trivial` module, arguments passed at the command line configure functions that pass values to other dynamical components. 

The design pattern is followed: parameters can be viewed with `get_Lpars` and the method for setting parameter values by passing a named list of values to `Lopts` in `xds_setup()` 

### Solving 

After setting up, `model` has an empty placeholder for outputs:

```{r}
model$outputs 
```

Calling `xds_solve(model)` returns solutions to the *initial value problem(s):* `xds_solve` calls `deSolve,` and the values of the dependent variables at a set of time points are attached as `model$outputs.` 

There are three ways to pass the argument `time` to `deSolve`: first, `xds_solve` can set up a vector of time points `seq(0, Tmax, by = dt)` that are configurable with the arguments `Tmax` and `dt;` second, if no arguments are passed for time, then it uses the defaults `Tmax=365` and `dt=1;` third, `deSolve` will use the optional argument `times` if it is supplied. All four of the following do the same thing: 

```{r, eval=F}
model <- xds_solve(model, times = 0:365) 
model <- xds_solve(model, times = 0:365, Tmax=730, dt=5) 
model <- xds_solve(model, Tmax=365, dt=1) 
```

```{r}
model <- xds_solve(model) 
```

Note `xds_solve` requires an **`xds`** *model object* and that it returns an **`xds`** *model object.* In this case, the function passes `model` and the return value replaces `model.` Before `xds_solve,` `model$outputs` was an empty list. After solving, the outputs are stored as `model$outputs`: 

```{r}
names(model$outputs)
```

The outputs from solving a system of equations include:

+ `time` -- are the time points when the values of the dependent variables were evaluated
+ `last_y` -- is the dependent variables at the last time point, the last state of the system  
+ `orbits` -- are the solutions with the values of the dependent variables parsed by name, accessible separately for each dynamical component 
+ `terms` -- dynamical terms describing transmission, including the EIR 
+ `deout` -- the raw (unparsed) outputs  

Note that the `time` holds the default values of the independent variable time where we solved the initial value problem for the dependent variables. 

```{r}
head(model$outputs$time, 5)
tail(model$outputs$time, 3)
```

When `xds_solve` is called, the **`xds` model object** it returns has replaced any old values. If nothing has changed, then the outputs will be identical. 

On the other hand, if anything has changed, any old outputs will get replaced. If the outputs need to be saved for future analyses, the user will probably have to write a wrapper function that extracts and saves it.

### Parsing 

To make it easy to deal with the outputs, the dependent variables are parsed and returned in named lists. `xde_solve()` also computes some standard *terms* that are likely to be of interest.  

Functions like `get_EIR()` make it easy to examine or save a set of standard outputs without delving into the details. 

```{r}
head(get_EIR(model), 3)
```

### Visualizing

**`ramp.xds`** includes functions to plot standard outputs:

- `xds_plot_X` plots the density of infected individuals

- `xds_plot_M` plots the density of adult female mosquitoes in each patch

- `xds_plot_Y` plots the density of infected adult female mosquitoes in each patch

- `xds_plot_Z` plots the density of infectious adult female mosquitoes in each patch

- `xds_plot_PR` plots the true prevalence of infection in the human / host population 

- `xds_plot_EIR` plots the EIR for each one of the human / host population strata

```{r, fig.height=5, fig.width=6, fig.cap = "**Figure 1:** Plotting standard outputs" }
par(mfrow = c(2,2))
xds_plot_X(model)
xds_plot_M(model)
xds_plot_Y(model, add=T)
xds_plot_Z(model, add=T)
xds_plot_PR(model)
xds_plot_EIR(model)
```

### Analysis

**`ramp.xds`** has built-in functions that compute some quantities of interest, including stable states or stable orbits. 


## Trivial Models and Trace Functions

The software was designed to be fully modular, so that any module for one dynamical component can be replaced with another. The models included in **`ramp.xds`** are just enough to illustrate its the features ensure that the software is working as it should.

A basic requirement for full modularity is that every dynamical component must include a *trivial* module. In the `trivial` module, no variables are defined, but the dynamical terms needed by related dynamical components are passed by a configurable *trace* function with a generic form:

```{r, eval=F}
mean*F_season(t, phase, season_opts)*F_trend(t, trend_opts)
```

The default for the $\cal L$ dynamical component is the `trivial` module, where the `mean` is is called `Lambda.`

It is easy to change the `trace` function. First, we define `F_season` and change the mean value of `Lambda.` 
The generic format for seasonal functions is `F_season(t, phase, season_opts),` where `phase` sets the phase (time of year), and `season_opts` is a set of configurable parameter values:

```{r}
 F_sp = function(t, phase, season_opts){
   return(with(season_opts,
          (1+sin(2*pi*(t+phase)/365))^pwr))} 
```

Having defined `F_sp,` we now configure a list of options:

```{r}
Lo = list(
       Lambda=500, 
       phase=90, 
       season_opts=list(pwr=2),
       F_season=F_sp
      )
```

We use the first model as a template for the new model, but we assign the return value a new name `model_1` so that the original one still exists: 

```{r}
model_1 <- make_Lpar("trivial", model, 1, Lopts=Lo)
```

We want to change the initial values of `model_1.` Since `model_1` was copied from `model,` the last values from solving it are available, and we can use a function `last_to_inits` to set the initial values.

```{r}
model_1 <- last_to_inits(model_1)
```

Now, we solve it over a three year period

```{r}
model_1 <- xds_solve(model_1, Tmax=365*3, dt=5) 
```

and plot the results. 

```{r, fig.height=2.6, fig.width=6, fig.cap = "**Figure 2:** Outputs with Seasonal Forced Emergence using a Trace Function" }
par(mfrow = c(1,2))
xds_plot_X(model_1)
xds_plot_M(model_1)
xds_plot_Y(model_1, add=T)
xds_plot_Z(model_1, add=T)
```


For more information, see the vignette [Trace Functions](https://dd-harp.github.io/ramp.xds/articles/TraceFunctions.html)

## Model Building

From a design perspective, the setup interface can't possibly anticipate the needs of every end user. Instead, it has adopted a system for *progressive model building* based on a framework designed for *scaling complexity.* 

The a mathematical framework supported the design of **`ramp.xds.`** That framework handles a subset of the universe of all possible models. That subset is understood as nested, hierarchical sets of models expanding out from a set of simple base models. Simpler model families are a nested within some complex model families. 

Rather than try and construct a supermodel, the software includes a set of **modules** for each one of the **dynamical components.** Each module defines a *model families* at some maximum level of complexity. Any new module can be added, and it might be better than any model that was already included, but the simple models can be used to get some work done in the meantime. 

### Modularity

The framework is designed around five dynamical components organized into three chunks: 

1. The vertebrate host population, denoted $\cal XH$: 

    + human (or host) demography ($\cal H$) including births, deaths, aging and migration;

    + malaria epidemiology ($\cal X$), in the narrow sense; or more generally, the dynamics of infection and immunity in the host population;  

2. The adult mosquito population, denoted $\cal MYZ$: 

    + mosquito ecology ($\cal M$) 

    + mosquito infection dynamics ($\cal Y$) 

3. Aquatic mosquito ecology,  denoted $\cal L$ 

These three chunks are connected by two interfaces. The first two chunks are connected through the rigid interface describing blood feeding and transmission, denoted $\cal B$. The last two chunks are connected through egg laying and emergence, $\cal N, U$. 

***

![**Figure 2** Modular dynamic components that form the core of **`ramp.xds`**](notation1.png)

***

### Modules 

In general, *module* is the term we use to describe an element in the model library. Since the parameter values can be changed, each *module* defines a *model family* in the form of a system of differential or difference equations. Each family is defined by a set of states and state transitions (*i.e.* by the topology of the graph) for a single population (`nStrata=1`). 

For example, the `SIS` module for the $\cal X$ component is the *SIS* compartmental model family for human infections. It's called a model family because each unique set of parameters would define a different *model.* 

In its simplest form, each model family represents the state of a single population, but any model can replicate those states and sub-divide a single population into sub-populations with different parameters. These are population strata for $\cal X$; adult mosquitoes in patches for $\cal MYZ$; immature mosquitoes in aquatic habitats for $\cal L$. In **`ramp.xds`** it is comparatively simple to configure a model with multiple strata, patches, and habitats. 

Each model developed in **`ramp.xds`** is thus characterized by:

+ The choice of *model family* for each dynamical component, model parameters, and initial values. 

+ The model structure, including the number of patches, the number of habitats and their membership in the patches, and the number of human population strata and their residency within the strata. 

+ Functions that define exogenous variables and functional responses that drive exogenous forcing by weather and malaria control.  

## Progressive Setup  

The concept for designing a setup interface to support complexity scaling in model building works bass ackwards. Basic setup was designed around simple models with structural flexibility. Each model returned by basic setup could serve as a platform for developing models of unbounded realism and complexity. To make this work, the software built in ports and junctions that could handle a large set of advanced features, but most of these features would be turned off for basic setup. Model building is handled in two steps:

+ **Basic Setup** is handled by the function `xds_setup().` It's designed to help a user get started with a properly formulated interface that can handle spatial dynamics, structured aquatic habitats, and a stratified human population.

+ **Advanced Setup** handles advanced features, including exogenous forcing, vector control, and other modes of malaria control, human demography and aging, and host population stratification. 

### Basic Setup  

*For our purposes, **Basic Setup** encompasses the configurable options in `xds_setup().`*

The software supports a modular framework for model building that is highly flexible and extensible. It's capable of building very realistic models, but progressive setup embraces a model-building philosophy of starting simple and adding realism or complexity one step at a time. 

The demo model, above, is one version of the Ross-Macdonald model. It illustrates how the software has streamlined the process of building fairly simple models. The following sections describe how to make **`ramp.xds`** build models that are much more complicated and realistic. 

As described above, the `xds_setup()` function **`ramp.xds`** has assigned default options for everything. Each model must configure three dynamical components: human epidemiology; adult mosquito ecology and infection dynamics; and aquatic mosquito ecology. Each one of these three dynamical component is configured by specifying a model name (as a string) and options, passed as a named list, to override the defaults for the model: 

+ `Xname` dispatches a model family for parasitic infections and immunity in the human population, called $\cal X.$ The setup default model is `Xname="SIS"` and default parameters for the `SIS` model are defined in `create_Xpar_SIS.` To replace the default values at setup, a named list can be passed as `Xopts = list(...)` and the named values in `Xopts` will be 
he values of named parameters and the initial values of named variables instead of the defaults. (The human demographic model, $\cal H$ is set up as an advanced option.) 

+ `MYZname` dispatches a model family for adult mosquito ecology and parasite infection dynamics, $\cal MYZ.$ The setup default model is `MYZname="macdonald"` and default parameters for the `macdonald` model are defined in `create_MYZpar_macdonald.` To replace the default values at setup, a named list can be passed as `MYZopts = list(...)` and the named values in `MYZopts` will set the values of named parameters and the initial values of named variables instead of the defaults.  

+ `Lname` specifies a model family for aquatic mosquito ecology, $\cal L.$  The setup default model is the trivial model `Lname = "trivial"`. It has no variables, but it passes the outputs -- emerging adults -- as a parameter. To replace the default values at setup, a named list can be passed as `Lopts = list(...)` and the values in `Lopts` will set the values of named parameters and the initial values of named variables instead of the defaults.  

Thu function call: 

```{r, eval=F}
model1 = xds_setup()
```

returns the same values as the function call: 

```{r, eval=F}
model2 = xds_setup(Xname = "SIS", 
                   MYZname = "macdonald", 
                   Lname = "trivial")
```

### Structural Parameters 

Structural parameters describe things like the number of patches, the number of population strata, the number of aquatic habitats, the number of host species, and the number of vector species. `xds_setup` sets up models with one host species and one vector species, users can configure a malaria landscape with *spatial dynamics,* structured *aquatic habitats,* and *multiple human / host* population strata. Basic setup was developed to ensure that all interfaces are set up properly when there are multiple patches, multiple habitats, multiple population strata, and malaria importation. The software and documentation follow the mathematical framework formulas and (with small changes) the notation in [Wu SL, *et. al.* 2023](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1010684). The following structural parameters can be set through `xds_setup:`
    
- **`nPatches`** or $n_p$ is the number of patches in the model. 
    
- **`membership`** is set up by passing a vector with the identity of patch where each habitat can be found, and it sets up the habitat matrix, $\cal N$. Setup sets the value of a variable describing the number of habitats, $n_q$ = **`nHabitats <- length(membership)`.** One configurable option is **`searchQ`** with the habitat search weights. 
    
- **`HPop`** is a vector with human population density, and **`residence`** is a vector describing the location of the patch where each stratum resides.  Setup checks that `length(HPop) == length(residence)` and sets the number of strata, $n_h$ or **`nStrata <- length(residence)`.** It is also possible to configure heterogeneous biting at the command line by passing **`searchH`** 
    
- If `nPatches >1` then other setup-configurable options are to pass:
    
    - a matrix `calK` describing mosquito dispersal among the patches.  
          
    - a matrix `TimeSpent` can be passed to configure human time spent  

To learn more, we suggest taking a look at the [5-3-4 Vignette](https://dd-harp.github.io/ramp.xds/articles/ex_534.html), a model with 5 aquatic habitats, 3 patches, and 4 human population strata.  

### Spatial Mosquito Ecology  

In **`ramp.xds`,** mosquito spatial ecology is implemented in a patch-based simulation model: a spatial domain is subdivided into patches; and each patch contains an arbitrary number of habitats.

### Spatial Transmission Dynamics

In **`ramp.xds`,** malaria spatial dynamics are implemented through a model of blood feeding in a patch-based simulation model.

```{r}
model5 <- xds_setup(nPatches=4)
```


### Human / Host Population Strata 

## Advanced Setup 

***NOTE:**  As demos for these advanced options get developed, we will add the links here.* 

**Advanced Setup Options:** During basic setup, two advanced options can be configured, but most of the advanced options must be added after basic setup.  

### Spatial Dynamics 

+ **Spatial Heterogeneity** -- 

+ **Human Mobility** -- 

- **Malaria Importation** includes *travel* and *visitors*

    - *Travel Malaria* --In basic setup, travel malaria is set up to model exposure while traveling, but time spent traveling and the travel FoI are set to zero. 
    
    - *Visiting* --  In basic setup, visiting is set up but the availability of visitors is set to zero.
    
+ **Exposure** -- Since catch counts data for mosquitoes are usually well-described by the negative binomial distribution family, **`ramp.xds`** has implemented a step between the computation of the EIR and the FoI to model [*environmental heterogeneity*](https://dd-harp.github.io/ramp.xds/articles/heterogeneous_transmission.html#environmental-heterogeneity-in-exposure) based on a probability distribution function describing the number of infective bites per person. By default, `xds_setup` configures a Poisson model, but this can be changed. 

+ **Human Demography** -- In basic setup, the human demographic model is the *trivial* model, but it can be configured to include

    - Vital dynamics: births, deaths
    
    + Migration 
    
    - Cohort dynamics and aging  
    
    - Pregnancy 



- **Forcing** -- set up exogenous forcing, including *exogenous variables* (*e.g.* weather and hydrology) and the *functional responses* to compute mosquito bionomic parameters 

- **Vector Control** -- set up vector control, including  

- **Health Systems** -- a variety of functions to handle surveillance and malaria control through health systems, including care seeking, mass vaccination, IPTp

- **Multiple Vector Species** -- Each vector species has spatial structure, but it is also possible to configure other vector species (or type). 

- **Multiple Host Species** -- Each host species can be stratified, but it is also possible to configure other host species (or types) to make setup and configuration easier. 

*** 

![**Figure 3** -- The modular structure and extensibility of **`ramp.xds`**.](ModularGeneralized.png)


